import { ICompare, PriorityQueue } from "@datastructures-js/priority-queue";
import { DateRecurrenceIterator } from "./dateTimeUtils";

export const compoundIterator = (
	inclusions: DateRecurrenceIterator[],
	exclusions: DateRecurrenceIterator[]
) => {
	let pending: HeapElement | undefined;

	/**
	 * The number of inclusions on the queue. We keep track of this so that we
	 * don't have to drain the exclusions to conclude that the series is
	 * exhausted.
	 */
	let nInclusionsRemaining: number = 0;

	/**
	 * Creates an iterator that will generate only dates that are generated by
	 * inclusions and will not generate any dates that are generated by
	 * exclusions.
	 * @param inclusions iterators whose elements should be included unless
	 * explicitly excluded
	 * @param exclusions iterators whose elements should not be included
	 */
	const queue = new PriorityQueue<HeapElement>(HeapElement.CMP);
	for (const it of inclusions) {
		const el = new HeapElement(true, it);
		if (el.shift()) {
			queue.push(el);
			++nInclusionsRemaining;
		}
	}
	for (const it of exclusions) {
		const el = new HeapElement(false, it);
		if (el.shift()) {
			queue.push(el);
		}
	}

	const reattach = (el: HeapElement): void => {
		if (el.shift()) {
			queue.push(el);
		} else if (el.inclusion) {
			/*
			 * If we have no live inclusions, then the rest are exclusions which
			 * we can safely discard.
			 */
			if (--nInclusionsRemaining == 0) {
				queue.clear();
			}
		}
	};

	const requirePending = () => {
		if (!!pending) {
			return;
		}

		let exclusionComparable = new Date(1, 1, 1);
		while (nInclusionsRemaining != 0 && !queue.isEmpty()) {
			//find a candidate that is not excluded
			let inclusion: HeapElement | undefined = undefined;
			do {
				const candidate = queue.pop();
				if (candidate.inclusion) {
					if (exclusionComparable != candidate.head) {
						inclusion = candidate;
						break;
					}
				} else {
					exclusionComparable = candidate.head!;
				}

				reattach(candidate);
				if (nInclusionsRemaining == 0) {
					return;
				}
			} while (!queue.isEmpty());
			if (inclusion == null) {
				return;
			}

			const inclusionComparable = inclusion.head;

			/*
			 * Check for any following exclusions and for duplicates. We could
			 * change the sort order so that exclusions always preceded
			 * inclusions, but that would be less efficient and would make the
			 * ordering different than the comparable value.
			 */
			let excluded = exclusionComparable == inclusionComparable;
			while (
				!queue.isEmpty() &&
				queue.front().head == inclusionComparable
			) {
				const match = queue.pop();
				excluded = excluded || !match.inclusion;
				reattach(match);
				if (nInclusionsRemaining == 0) {
					return;
				}
			}
			if (!excluded) {
				pending = inclusion;
				return;
			}
			reattach(inclusion);
		}
	};

	const hasNext = () => {
		requirePending();
		return pending != null;
	};

	const next = (): Date | undefined => {
		requirePending();
		if (!pending) {
			throw new Error("No pending elements");
		}

		const head = pending.head;
		reattach(pending);
		pending = undefined;
		return head;
	};

	return {
		next,
		hasNext,
	};
};

class HeapElement {
	/**
	 * The last value removed from the iterator (in UTC).
	 */
	public head: Date | undefined = undefined;

	public constructor(
		public readonly inclusion: boolean,
		public readonly it: DateRecurrenceIterator
	) {}

	/**
	 * Discards the current element and move to the next.
	 * @return true if there is a next element, false if not
	 */
	public shift(): boolean {
		if (!this.it.hasNext()) {
			return false;
		}

		this.head = this.it.next();
		return true;
	}

	/**
	 * Compares two heap elements by comparing their heads.
	 */
	static CMP: ICompare<HeapElement> = (a, b) => {
		if (a.head === b.head) return 0;
		if (!a.head) return 1;
		if (!b.head) return -1;
		return a.head < b.head ? -1 : 1;
	};
}
